# 类加载器

ClassLoader（类加载器）负责将Class加载到JVM中，主要功能：
+ 将Class加载到JVM中
+ 审查每个类应该由谁加载，使用父优先的等级加载机制
+ 将Class字节码重新解析成JVM统一要求的对象格式

## 一、类结构分析

 使用或扩展ClassLoader主要会用到的方法：
 ![ClassLoader类主要结构信息](https://raw.githubusercontent.com/McHeat/Note/master/img/classloader/ClassLoader01.JPG)
 
 + ***defineClass*** \
   将byte字节流解析成JVM能够识别的CLass对象
 + ***findClass*** \
   实现类的加载规则，从而取得要价在类的字节码
 + ***resolveClass*** \
   使类被加载到JVM中时被链接(Link)
 + ***loadClass*** \
   在运行时加载指定的一个类
   
 ClassLoader是一个抽象类，实现自定义ClassLoader一般都会继承**URLClassLoader**子类，因为这个子类已实现了大部分功能。
 ClassLoader还提供了一些辅助方法，如获取class文件的方法***getResource***、***getResourceAsStream***等，还有获取SystemClassLoader的方法等。
 
## 二、等级加载机制


 ClassLoader使用的接待机制为**上级委托接待机制**。
 会员到达任一会员接待室时，接待室先判断是否会员已被自己接待过，如果已接待过则拒绝本次接待，如果没有接待过则向上询问是否应该在上一级的更高级别的接待室接待。
 上一级接待室根据接待规则执行同样的处理方法。直到有一级接待室接待或者告诉它下一级这个会员不是自己接待的结果。

 整个JVM平台提供三层ClassLoader:  
 + ***Bootstrap ClassLoader*** \
   主要加载JVM自身工作需要的类，完全是由JVM自己控制，既没有更高一级的父加载器，也没有子加载器。
 + ***ExtClassLoader*** \
   是JVM自身的一部分，服务的特定目标在`System.getProperty("java.ext.dirs")`目录下。
 + ***AppClassLoader*** \
   父类是ExtClassLoader，所有在`System.getProperty("java.class.path")`目录下的类都可以被加载，这个目录就是classpath。  
   自定义的类加载器，无论是直接实现抽象类ClassLoader，还是继承URLClassLoader类或者其他子类， 父加载器都是AppClassLoader，因为不管调用哪个父类构造器，创建的对象都必须最终调用```getSystemClassLoader()```作为父加载器，而这方法获取的正是AppClassLoader。  
   
 Bootstrap ClassLoader不属于JVM的类等级层次，且没有子类。  
 ExtClassLoader的父类不是Bootstrap ClassLoader，ExtClassLoader并没有父类，是应用中的顶层父类。  
 ExtClassLoader和AppClassLoader都位于sun.misc.Launcher类中，是Launcher的内部类。 
 在创建Launcher对象时首先会创建ExtClassLoader，然后ExtClassLoader对象作为父加载器创建AppClassLoader对象， 
 通过Launcher.getClassLoader()方法获取的ClassLoader就是AppClassLoader对象。 如果在Java应用中没有定义其他ClassLoader，那么除了System.getProperty("java.ext.dirs")目录下的类是由ExtClassLoader加载外，其他类都由AppClassLoader来加载。  
      
 JVM加载class文件到内存有两种方式：
 - 隐式加载  
   不通过在代码里调用ClassLoader来加载需要的类，而是通过JVM来自动加载需要的类到内存的方式。
 - 显式加载  
   在代码中通过调用ClassLoader类来加载一个类的方式。
   
## 三、如何加载class文件


## JVM体系结构

### 一、计算机的体系结构
 + **指令集** ：计算机所能识别的机器语言的命令集合
 + **计算单元** ：能够识别并且控制指令执行的功能模块
 + **寻址方式** ：地址的位数、最小地址和最大地址范围、以及地址的运行规则
 + **寄存器定义** ：包括操作数寄存器、变址寄存器、控制寄存器等的定义、数量和使用方式
 + **存储单元** ：能够存储操作数和保存操作结构的单元，如内核级缓存、内存和磁盘等
 
 当前计算机主流的体系结构上分为**精简指令集**(`RISC`)和**复杂指令集**(`CISC`)。  
 指令集与汇编语言的关系：  
 指令集是可以直接被机器识别的机器码，必须以二进制格式存在于计算机中。  
 汇编语言是能够被人识别的指令，在顺序和逻辑上是与机器指令一一对应的。  
 
 CPU的架构会影响指令集。不同的芯片架构设计一定会对应到不同的机器指令。但现在不同的芯片厂商往往都会采用兼容的方式兼容其他不同架构的指令集。
 
 能够被JVM解析执行的指令集称为**JVM字节码指令集**。
 
### 二、JVM体系结构
 JVM的体系结构基本上由4部分组成：
 + 类加载器
   在JVM启动时或者在类运行时将需要的class加载到JVM中。每个被JVM装载的类型都有一个对应的java.lang.Class类的实例来表示该类型，
   该实例可以唯一表示被JVM装载的class类，与其他类的实例一样存放在Java的堆中。
 + 执行引擎
   是JVM的核心部分，负责执行class文件中包含的字节码指令，相当于实际机器上的CPU。
   执行引擎是执行一条条代码的一个流程，一个Java线程就是一个执行引擎的实例。在一个JVM实例中同时有多个执行引擎在工作。
 + Java内存管理
   一个Java实例会有一个方法区、Java堆、Java栈、PC寄存器和本地方法区。方法区和Java堆是所有线程共享的，可以被所有的执行引擎实例访问到。
   每个执行引擎实例被创建时都会创建一个Java栈和一个PC寄存器。Java栈存储线程中方法调用的状态，PC寄存器执行即将执行的下一条指令。
 + 本地方法调用
   调用C或C++实现的本地方法的代码返回结果。  
    
### 三、JVM工作机制
 程序从编写到执行经历的阶段：源代码（source code） -> 预处理器（preprocessor） -> 编译器（compiler） 
 -> 汇编程序（assembler） -> 目标代码（object code） -> 链接器（Linker） -> 可执行程序（executables）  
 
 JVM执行字节码指令是基于栈的架构，所有的操作数必须先入栈，然后根据指令中的操作码选择从栈顶弹出若干个元素进行计算后再将结果压入栈中。
 在JVM中操作数可以存放在每一个栈帧中的一个本地变量集中，即在每个方法调用时就会给这个方法分配一个本地变量集，这个变量集在编译时就已经确定，
 所以操作数入栈可以直接是常量入栈或从本地变量集中取一个变量压入栈中。    
 JVM基于栈来设计的理由，一个是JVM要设计成与平台无关，要保证在没有或有很少寄存器的机器上也能正确运行Java代码。
 还有一个理由是为了指令的紧凑性，因为Java的字节码可能在网络上传输，所以class文件的大小也是设计JVM字节码指令的一个重要因素。  
 
 每当创建一个新的线程时，JVM会为这个线程创建一个Java栈，同时会为这个线程分配一个PC寄存器，寄存器会指向线程的第一行可执行代码。
 每当调用一个新方法时会在这个栈上创建一个新的栈帧数据结构，栈帧会保留方法的一些元信息如方法的局部变量、用来支持常量池的解析、正常方法返回和异常处理机制。
 JVM在调用某些指令时可能需要使用到常量池中的一些常量，或者是获取常量代表的数据或者数据指向的实例化的对象，这些信息存放在所有线程共享的方法区和Java堆中。  
 
 
# 并发的理解与汇总

## 一、并发编程的挑战
并发编程的目的是为了让程序运行的更快，期间会面临着非常多的挑战：  

+ 上下文切换
   减少上下文切换的方法有：**无锁并发编程**、**CAS算法**、**使用最少线程**和 **使用协程**。
+ 死锁  
   避免死锁的常见方法：  
    - 避免一个线程同时获取多个锁
    - 避免一个线程同时占用多个资源，尽量保证每个锁只占用一个资源
    - 尝试使用定时锁
    - 对于数据库锁，加锁和解锁必须在一个数据库连接中
+ 硬件和软件的资源限制

## 二、并发机制的底层实现原理

volatile变量
--- 

Java语言规范对volatile的定义：Java编程语言允许线程访问共享变量，为了确保共享变量被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。  

volatile变量修饰共享变量进行写操作时会插入Lock前缀的汇编指令。实现原则： 

+ Lock前缀指令会引起处理器缓存回写到内存。
+ 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。

synchronized
---

利用`synchronized`实现同步的基础：Java中的每个对象都可以作为锁。  

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，其中代码块同步使用`monitorenter`和`monitorexit`指令实现的，而方法同步使用的其他未明示的方式实现。`monitorenter`指令在编译后插入到同步代码块的开始位置，而`monitorexit`插入到方法结束处和异常处。  

`synchronized`用的锁存在Java对象头里。存储非数组类型的对象头使用2字宽（8个字节），存储数组类型的对象头使用3字宽（12个字节）。  

| 长度 | 内容 | 说明 |
|--|--|--|
| 32/64bit | Mark Word | 存储对象的hashCode或锁信息等 |
| 32/64bit | Class Metadata Address | 存储对象类型数据的指针 |
| 32/64bit | Array Length | 存储数组长度（对象为数组类型时存在） |

线程在执行同步代码块前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中，官方称为`Displaced Mark Word`。锁一共存在4中种状态，级别从低到高分别为：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，锁可以升级但不可以降级。  

1. 偏向锁  
    在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，为降低线程获取锁的代价而引入了偏向锁。  
    **偏向锁的获取**：当一个线程访问同步块并获取锁时，在**对象头**和**栈帧中的锁记录**里存储锁偏向的线程ID，**释放锁时会将对象头中记录线程ID的位置置空**。  
    **偏向锁的撤销**：偏向锁采用 **等到竞争出现才会释放锁**的机制，当其他线程在运行期间尝试竞争偏向锁时，持有偏向锁的线程会被挂起，JVM会尝试消除偏向锁并回复到标准的轻量级锁。偏向锁的撤销需要等待全局安全点。  
    **偏向锁的参数**： `-XX:BiasedLockingStartupDelay=0`关闭偏向锁的延迟启动；`-XX:-UseBiasedLocking`关闭偏向锁，默认启动轻量级锁。
2. 轻量级锁  
    轻量级锁是通过CAS来**避免进入开销较大的互斥操作**。  
    **轻量级锁加锁**：线程会尝试使用CAS将对象头中的Mark Word替换成指向锁记录的指针，如果成功则获得锁，如果失败则表示其他线程竞争锁，当前线程尝试使用**自旋**来获取锁。  
    **轻量级锁解锁**：轻量级锁解锁时，使用原子的CAS操作来将Displaced Mark Word替换回对象头，如果成功则表示没有竞争发生，如果失败则**锁膨胀**为重量级锁。  

3. 重量级锁  
    
原子操作(atomic operation)
---
原子操作即**不可被中断的一个或一系列操作**。  

1. 术语定义  

| 术语名称 | 英文 | 解释 |
|--|--|--|
| 缓存行 | Cache Line | 缓存的最小行 |
| 比较并交换 | Compare And Swap | CAS操作需要两个值，一个旧值（期望操作前的值）和一个新值 |
| CPU流水线 | CPU pipeline | 在CPU中由5\~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5\~6步后再由这些电路单元分别执行 |
| 内存顺序冲突 | Memory order violation | 内存顺序冲突一般是由假共享导致，假共享是指多个CPU修改同一个缓存行的不同部分而导致其中一个CPU的操作无效 |


2. 处理器实现原子操作  
   处理器提供**总线锁定**和**缓存锁定**两种机制来保证复杂内存操作的原子性。总线锁定使用`LOCK#`信号来阻塞其他处理器的请求。  

3. Java实现原子操作
   在Java中可以通过锁和循环CAS的方式实现原子操作。而CAS操作的三个主要问题：**ABA问题**、**循环时间长开销大**和**只能保证一个共享变量的原子操作**。















































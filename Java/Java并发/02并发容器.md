# ConcurrentHashMap的实现（Java7）

### 1. ConcurrentHashMap的比较
+ **线程不安全的HashMap**  
 HashMap在并发执行put操作时会引起死循环，因为多线程会导致HashMap的Entry链表形成环形数据结构。
+ **效率低下的HashTable**  
 HashTable使用synchronized来保证线程安全，导致在线程竞争激烈的情况下HashTable的效率分厂低下。因为同步方法的访问会导致竞争线程进入阻塞或轮询状态。
+ **锁分段技术的ConcurrentHashMap**  
 ConcurrentHashMap容器有多把锁，每一把锁用于锁定容器中一部分数据，在多线程访问容器里不同数据段的数据时，线程间不会存在锁竞争，从而提高并发访问效率。  
 
### 2. ConcurrentHashMap的结构
ConcurrentHashMap由**Segment数组结构**和**HashEntry数组结构**组成。    
+ 一个ConcurrentHashMap里包含一个Segment数组；
+ Segment结构与HashMap类似，包含一个HashEntry数组；
+ 一个HashEntry是一个链表结构的元素，用于存储键值对数据；
+ Segment是一种可重入锁，用来确保其中的HashEntry数组的线程安全。

### 3. ConcurrentHashMap的初始化
ConcurrentHashMap初始化方法通过`initialCapacity`、`loadFactor`和`concurrencyLevel`等参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现。  

### 4. 定位Segment
在插入和获取元素时，ConcurrentHashMap必须先通过散列算法定位Segment。

### 5. ConcurrentHashMap的操作
+ get操作  
 get操作非常简单和高效，整个过程不需要解锁，除非读取到的值为空才会加锁重读。get操作中将要使用的共享变量都定义为volatile类型，以在线程间保持可见性，能够被多线程同时读且不会读到过期的值，但只能被单线程写。
+ put操作  
 put方法会对共享变量进行写入操作，所以为了线程安全必须加锁。首先定位到Segment，然后在Segment里进行插入操作。插入操作主要分两步：  
   - 是否需要对Segment里的HashEntry数组进行扩容  
   - 定位添加元素的位置，然后将其放在HashEntry数组里
+ size操作  
 整个ConcurrentHashMap的大小，需要统计所有Segment里的元素的大小后求和。基于累加count的过程中，count可能发生变化但几率较小，ConcurrentHashMap先尝试2次通过不锁定Segment的方式统计各个Segment大小，如果统计过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。  
 判断变化的方式：通过modCount变量，在put、remove和clean方法里操作元素都会将变量modCount加1，统计size前后比较modCount是否发生变化，从而得知容器大小是否发生变化。  


---
# ConcurrentHashMap的实现（Java8）
Java8中ConcurrentHashMap与Java7的差别：  
+ 取消segment字段，直接采用了`transient volatile Node<K,V>[] table`保存数据，采用table数组元素作为锁，实现对每一行数据进行加锁，进一步减少并发冲突的概率；
+ 将`table数组+单向链表`的数据结构，变更为`table数组+单向链表+红黑树`的结构。对于个数超过8（默认值）的列表，采用红黑树的结构，降低查询时间复杂度为O(logN)。  

---

# ConcurrentLinkedQueue



--- 

# 阻塞队列




---  


# Fork/Join框架
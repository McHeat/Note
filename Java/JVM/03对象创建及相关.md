## 对象的内存布局
  分为三块区域：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)  
 + 对象头(Header)  
   - Part1.MarkWord，存储对象自身的运行时数据，是与对象自身定义的数据无关的额外存储成本(在轻量级锁和偏向锁中有重要应用)  
   - Part2.类型指针，即对象指向它的类元数据的指针，可用于确定是哪个类的实例  
 + 实例数据(InstanceData)  
    对象真正存储的有效信息，程序代码中定义的各类型字段内容  
    存储顺序受虚拟机分配策略参数和字段定义顺序影响  
 + 对齐填充(Padding)  
    非必然存在，仅起占位符作用

## 对象的创建（虚拟机遇到new指令时的处理）
1. 类加载检查。指令的参数在常量池中是否有类的符号引用，及加载、解析和初始化
2. 为新生对象分配内存。划分方式分为“指针碰撞”和“空闲列表”。
  + 解决并发时内存分配问题：同步处理内存分配动作、使用TLAB  
  TLAB(本地线程分配缓冲)：每个线程在Java堆中预先分配一小块内存，通过-XX:+/-UseTLAB参数来设定
3. 将分配到的内存空间初始化为零值。
4. 对对象进行必要的设置。  
存储在对象头中的信息，如对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、GC分代年龄等。
5. 执行init方法

## 对象的访问定位
1. 通过栈上的reference数据来操作堆上的具体对象
2. 主流的对象访问方式有使用句柄和直接指针两种
  + 句柄访问：  
	Java堆中划分内存作为句柄池，reference存储对象的句柄地址。句柄中包含了对象实例数据和类型数据各自的具体地址信息
  + 直接指针：  
	对象的布局中放置类型数据的相关信息，reference中直接存储对象地址 
	
## 引用扩充
+ **强引用(Reference)**  
  强引用存在时，垃圾收集器永远不会回收被引用的对象
+ **软引用(SoftReference)**  
  描述有用但并非必需的对象，在内存将要溢出异常前会被列入回收范围进行第二次回收
+ **弱引用(WeakReference)**  
  描述非必需对象，且强度弱于软引用，被引用对象只能生存到下一次GC收集前。
+ **虚引用(PhantomReference)**  
  又称幽灵引用或幻影引用，是最弱的一种引用关系。完全不会对生存时间构成影响，也无法通过虚引用来取得一个对象实例。  

## 对象存活判断：
+ **引用计数算法**：  
方法简单，但无法解决对象之间的相互循环引用问题
+ **可达性分析算法**(实际使用)：  
  - **GC Roots**对象作为起点向下搜索，所走过的路径称为**引用链**。  
  - 无引用链相连的对象不可用
  - 可作GC Roots的对象：  
	  1. 虚拟机栈中引用的对象
	  2. 方法区中类静态属性引用的对象
	  3. 方法区中常量引用的对象
	  4. 本地方法栈中JNI(Native方法)引用的对象
  - 过程：  
    1. 对象不可达时会被标记且没覆盖finalize()方法或已被调用，将被放置到F-Queue队列中
	2. GC对F-Queue中的对象进行二次小规模标记
	3. 对象可通过finialize()方法从F-Queue逃脱来避免被回收（仅限一次）
	4. 对象未逃脱时将会被回收
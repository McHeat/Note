# Java虚拟机 

> Java虚拟机与Java语言并没有必然的联系，只与特定的二进制文件格式——class文件格式所关联。class文件包含了Java虚拟机指令集（或称为字节码）和符号表，以及其他一些辅助信息。  
基于安全方面的考虑，Java虚拟机在class文件中施加了许多强制性的语法和结构化约束，凡是能够用class文件正确表达出来的编程语言，都可以放在Java虚拟机中执行。  

## 1. class文件格式
编译后被Java虚拟机执行的代码使用了一种平台中立（不依赖于特定硬件及存储设备）的二进制格式来表示，
并且经常以文件的形式存储，这种格式称为class文件格式。  
class文件格式中精确地定义了类与接口的表示形式，包括在平台相关的目标文件格式中一些细节的惯例。

## 2. 数据类型
编译器应当在编译期间尽最大努力完成可能的类型价差，使得虚拟机在运行期间无需进行这些操作。  
Java虚拟机的数据类型分为两类：  
1. 原始类型(primitive type)  
Java虚拟机所支持的原始数据类型那个包括**数值类型**、boolean类型和returnAddress类型。
   + 数值类型  
     分为**整数类型**和**浮点类型**。  
       - 整数类型
       
         | 类型 | 取值范围 | 描述 |
         | :---: | :--- | --- | 
         | byte   | -128 ~ 128  (-2<sup>7</sup> ~ 2<sup>7</sup>-1) | 值为8位有符号二进制补码整数，默认为零。    | 
         | short  | -32768 ~ 32767  (-2<sup>15</sup> ~ 2<sup>15</sup>-1) | 值为16位有符号二进制补码整数，默认值为零。  |
         | int    | -2<sup>31</sup> ~ 2<sup>31</sup>-1 | 值为32位有符号二进制补码整数，默认值为零。  |
         | long   | -2<sup>63</sup> ~ 2<sup>63</sup>-1 | 值为64位有符号二进制补码整数，默认值为零。  |
         | char   | 0 ~ 65535 | 值为16位无符号整数表示，指向基本多文种平面(BMP)的Unicode码点，以UTF-16编码，默认值为Unicode的null码点（'/u0000''）。 |
       - 浮点类型    
              
         | 类型 | 描述 |
         | :---: | --- | 
         | float | 值为单精度浮点数集合或单精度浮点扩展指数集合中的元素，默认值为正数0。 |  
         | double | 值为双精度浮点数集合或双精度扩展指数集合中的元素，默认值为正数0。 |  
         
         任何一个非零的、可数的任意浮点值都可以表示为s\*m\*2<sup>e-N+1</sup>，其中s可以是+1或者-1，m是一个小于2<sup>N</sup>的正整数，e是一个介于E<sub>min</sub>=-(2<sup>K-1</sup>-2)和E<sub>max</sub>=2<sup>K-1</sup>-1之间的整数。部分浮点数使用这种规则得到的表达形式可能不是唯一的。分为*标准表示*、*非标准表示*和*非标准值*。  
         **表2-1 浮点数集合的参数**  
         
         | 参数 | 单精度浮点数集合 | 单精度扩展指数集合 | 双精度浮点数集合 | 双精度扩展指数集合 |
         | --- | ------------- | --------------- | ------------- | --------------- |
         | N | 24 | 24 | 53 | 53 |
         | K | 8 | &gt;= 11 | 11 | &gt;= 15 |
         | E<sub>max</sub> | +127 | &gt;=+1023 | +1023 | &gt;=+16383 |
         | E<sub>min</sub> | -126 | &lt;=-1022 | -1022 | &lt;=-16382 |  
         
         上述四种集合都不仅包含可数的非零值，而且包含5个特殊的数值：正数零、负数零、正无穷大、负无穷大和NaN。  
         表2-1中的约束经过精心设计，保证每一个单精度浮点数集合中的元素都一定是单精度扩展指数集合、双精度浮点数集合和双精度扩展指数集合中的元素。
         同时，每一个双精度浮点数集合中的元素都一定是双精度扩展指数集合的元素。  
         NaN是无序的，只要操作数是NaN，那么对它进行任何数值比较和等值测试都会返回false。值得一提的是，有且只有NaN这一个数在与自身比较是否等值时会得到false。
         任何数字与NaN进行不等值比较都会返回true。
   + boolean类型  
     值为布尔值true和false，默认值为false。  
     Java虚拟机对boolean类型提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字J节码指令，Java语言表达式所操作的boolean值，在编译后都使用Java虚拟机中的int数据类型代替。   
     Java虚拟机直接支持boolean类型的数组，虚拟机的*newarray*指令可以创建这种数组。boolean类型数组的访问与修改共用byte类型数组的baload和bastore指令。  
     Java虚拟机会把boolean数组元素中的true值采用1来表示，false值采用0来表示，当Java编译器把Java语言中的boolean类型值映射为Java虚拟机的int类型时，必须采用上述表示方式。  
   + returnAddress类型  
     指向某个操作码的指针，此操作码与Java虚拟机指令相对应。在虚拟机支持的所有原始类型中，只有returnAddress类型是不能直接与Java语言的数据类型相对应的。无法在程序运行期间更改。
2. 引用类型(reference type)  
 Java虚拟机中有三种引用类型：**类类型(class type)**、**数组类型(array type)**和**接口类型(interface type)**。这些引用类型的值分别指向动态创建的类实例、数组实例和实现了某个接口的类实例或数组实例。  
 数组类型最外面的一维元素的类型，叫做该数组类型的**组件类型(component type)**。当迭代到组件类型不是数组时的类型称为本数组的**元素类型(element type)**。数组的元素类型必须是原生类型、类类型或接口类型之一。  
 引用类型的值中，有一个特殊的值：**null**，当一个引用不指向任何对象的时候，它的值就用null来表示。一个为null的引用，起初不具备任何实际的运行期类型，但可转型为任意的引用类型。引用类型的默认值就是null。  
 Java虚拟机规范并没有规定null在虚拟机实现中应当怎样用编码来表示。  
 
## 3. 运行时数据区 
 Java虚拟机定义了若干程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动和退出而创建或销毁。另外一些则是与线程一一对应的，会随着线程开始和结束而创建和销毁。  
 
### 3.1 pc寄存器
 Java虚拟机可支持多条线程同时执行，每一条线程都由自己的pc(program counter)寄存器。在任意时刻，一条线程只会执行一个方法的代码，称为该线程的当前方法。
 如果方法是native的，那么pc寄存器的值是undefined；如果方法不是native的，那么pc寄存器保存Java虚拟机正在执行的字节码指令的地址。
 pc寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。  

### 3.2 Java虚拟机栈
 每一条Java虚拟机线程都有自己私有的J**ava虚拟机栈**(Java Virtual Machine stack)。栈与线程同时创建，用于存储栈帧。作用：  
 + 存储局部变量与一些尚未算好的结果。  
 + 在方法调用和返回中担任重要角色。  
 
 因为除了栈帧的出栈和入栈之外，Java虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配。
 Java虚拟机栈所使用的内存不需要保证是连续的。  
 Java虚拟机规范允许Java虚拟机栈被实现成固定大小，也允许根据计算动态来扩展和收缩。采用固定大小的Java虚拟机栈时，
 每个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，应提供调节虚拟机栈初始容量的手段。对于动态扩展和收缩Java虚拟机栈，
 应当提供调节最大、最小容量的手段。  
 
 Java虚拟机栈可能发生如下异常情况：  
 + 如果线程请求分配的栈容量超出Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。
 + 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，Java虚拟机将会抛出一个OutOfMemoryError异常。
 
### 3.3 Java堆
 在Java虚拟机中，**堆**(heap)是可供所有线程共吸纳的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。  
 Java堆在虚拟机启动的时候就被创建，存储了被自动内存管理系统（即GC）所管理的各种对象，这些受管理的对象无需也无法显式地销毁。规范中未规定相关具体技术实现自动内存管理技术，
 虚拟机实现者可以根据系统根据系统的实际需要选择。  
 Java堆的容量可以是固定的，也可以随着承训执行的需求动态扩展或收缩，应提供调节初始容量或最大最小容量的手段。Java堆使用的内存不需要保证是连续的。  
 
 Java堆可能发生如下异常情况：  
 + 如果实际所需的堆超过了自动内存管理系统能提供的最大容量，Java虚拟机会抛出一个OutOfMemoryError异常。  
 
### 3.4 方法区
 在Java虚拟机中，**方法区**(method area)是可供各个线程共享的运行时内存区域。作用：  
 + 存储了每一个类的结构信息。  
 
 方法区在系统启动的时候创建，虽然方法区是堆的逻辑组成部分，但简单的虚拟机实现可选择在这个区域不是先垃圾收集与压缩。规范中未规定相关具体技术实现自动内存管理技术。  
 方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展或收缩，应提供调节初始容量或最大最小容量的手段。方法区在实际内存空间中可以是不连续的。  
 
 方法区可能发生如下异常情况：  
 + 如果方法区的内存空间不能满足内存分配请求，那么Java虚拟机将抛出一个OutOfMemoryError异常。  
 
### 3.5 运行时常量池
 **运行时常量池**(running constant pool)是class文件中每一个类或接口的常量池表的运行时表示形式，
 它包括了若干种不同的常量，从编译期可知的数值字面量到必须在运行期解析后才能获得的方法或字段引用。  
 每一个运行时常量池都在Java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。  
 
 在创建类和接口的运行时常量池时，可能会发生如下异常情况：  
 + 当创建类或接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，那么Java虚拟机将会抛出
 一个OutOfMemoryError异常。  

### 3.6 本地方法栈
 Java虚拟机实现可能会使用到传统的栈（通常称为C stack）来支持native方法的执行，这个栈称为
 **本地方法栈**(native method stack)。当Java虚拟机使用其他语言来实现指令集解释器时，
 也可以使用本地方法栈。如果支持本地方法栈，一般会在线程创建的时候按线程分配。  
 Java虚拟机规范允许本地方法栈实现成固定大小或根据计算来动态扩展和收缩，应提供调节初始容量
 或最大最小容量的手段。如果采用固定大小的本地方法栈，那么每一个线程的本地方法栈容量可以在
 创建栈的时候独立选定。  
 
 本地方法栈可能发生如下异常情况：  
 + 如果本地方法栈请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个
 StackOverflowError异常。  
 + 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程
 时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。  
 
## 4. 栈帧
 **栈帧**(frame)是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接、方法返回值
和异常分派。  
 栈帧随着方法调用而创建，随着方法结束而销毁（正常或异常）。栈帧的存储空间有创建它的线程分配在
Java虚拟机栈之中，每个栈帧都有本地变量表(local variable)、操作数栈(operand stack)和指
向当前方法所属的类的运行时常量池的引用。  
 本地变量表和操作数栈的容量在编译期确定，并通过相关方法的code属性保存及提供给栈帧使用。因此，
栈帧数据结构的大小仅仅取决于Java虚拟机的实现。实现者可以在调用方法时分配内存。  
 在线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的，称为**当前栈帧**
(current frame)。这个栈帧对应的方法称为**当前方法**(current method)，定义当前方法的
类称作**当前类**(current class)。调用新方法时，新的栈帧会随之创建，并随着程序控制权移交
到新方法而成为当前栈帧。方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，并丢弃当前
栈帧，使得前一个栈帧重新成为当前栈帧。  
 
### 4.1 局部变量表
 每个栈帧内部都包含一组称为局部变量表的变量列表。栈帧中局部变量表的长度由编译期决定，并存储于
类或接口的二进制表示之中，即通过方法的code属性保存及提供给栈帧使用。  
 一个局部变量可保存一个类型为boolean、byte、char、short、int、float、reference或returnAddress
的数据。两个局部变量可以保存一个类型为long或double的数据。  
 局部变量使用索引来定位访问。long和double类型的数据占用两个连续的局部变量，采用其中较小的索
引来定位。  
 Java虚拟机使用局部变量表来完成方法调用时的参数传递。当调用类方法时，方法的参数会依次传递到
局部变量表中从0开始的连续位置上。当调用实例方法时，第0个局部变量一定用来存储该实例方法所在
对象的引用（即Java语言中的this关键字），后续的其他参数会传递至局部变量表中从1开始的连续位
置上。  

### 4.2 操作数栈
每个栈帧内部都包含一个称为**操作数栈**的后进先出(LIFO)栈。栈帧中操作数栈的深度由编译期决定，并且
通过方法的code属性保存及提供给栈帧使用。  
栈帧在刚创建时，操作数栈是空的。Java虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制
常量或变量值到操作数栈中，也提供了一些指令用于从操作数栈取走数据、操作数据及把操作结果重新入栈。在
调用方法时，操作数栈也用来准备调用方法的参数以及接受方法返回的结果。  
操作数栈的每个位置上都可以保存一个Java虚拟机中定义的任意数据类型的值，包括long和double类型。  
在操作数栈中的数据必须正确地操作。有一小部分Java虚拟机指令可以不关注操作数的具体类型，把所有在运行
时数据区中的数据当作裸类型数据来操作，这些操作不能修改数据或拆散不可拆分的数据，操作的正确性通过class
文件的校验过程来强制保障。  
在任意时刻，操作数栈都会有一个确定的栈深度，一个long或double类型的数据会占用两个单位的栈深度，其他
数据类型会占用一个单位的栈深度。  

### 4.3 动态链接
每个栈帧内部都包含一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现**动态链接**。在class文件里面，一个方法若要调用其他方法或访问成员变量，则需要通过符号引用来表示，动态链接的作用就是将这些符号引用所表示的方法转换为对实际方法的直接引用。类加载的过程中将要解析尚未被解析的符号引用，并且将对变量的访问转化为变量的访问转化为变量在程序运行时，位于存储结构中的正确偏移量。  
由于对其他类中的方法和变量进行了晚期绑定，所以即便类发生变化也不会影响调用他们的方法。  

### 4.4 方法调用正常完成  
方法调用正常完成是指在方法的执行过程中，没有抛出任何异常。如果当前方法调用正常完成，很可能会返回一个值给调用它的方法。方法正常完成发生在一个方法执行过程中遇到了方法返回的字节码指令时，使用哪种返回指令取决于方法返回值的数据类型（如果有返回值）。  
当前栈帧承担着恢复调用者状态的责任，包括恢复调用者的局部变量表和操作数栈，以及正确递增程序计数器，以跳过刚才执行的方法调用指令等。调用者的代码在被调用方法的返回值压入调用者栈帧的操作数栈后，会继续正常执行。  

### 4.5 方法调用异常完成
方法调用异常完成是指在方法的执行过程中，某些指令导致了Java虚拟机抛出了异常，并且虚拟机抛出的异常在该方法中没有办法处理，或者在执行过程中遇到athrow字节码指令并显式地抛出异常，同时在该方法内部没有捕获异常。
如果方法异常调用完成，那一定不会有方法返回值返回给调用者。  
 
## 5 对象的表示
Java虚拟机规范不强制规定对象的内部结构应当如何表示。  

## 6. 浮点计算
Java虚拟机规范采纳了《IEEE Standard for Binary Floating-Point Arithmetic》浮点算法规范中的一个子集。

### 6.1 Java虚拟机和IEEE754中的浮点算法
Java虚拟机中支持的浮点算法和IEEE754标准中的主要差别：  
+ Java虚拟机中的浮点操作在遇到非法操作时，不会抛出exception、trap或IEEE754异常情况中定义的其他信号。  
+ Java虚拟机中没有信号NaN值(signaling NaN value)。  
+ Java虚拟机不支持IEEE754中的信号浮点比较。  
+ Java虚拟机的舍入操作永远使用IEEE754标准中定义的向最接近数舍入模式(round to nearest mode)。Java虚拟机并不给出改变浮点运算舍入模式的手段。  
+ Java虚拟机不支持IEEE754的单精度扩展和双精度扩展格式。  

### 6.2 浮点模式
每个方法都有一项属性称为**浮点模式**(floating-point mode)，取值为**FP-strict模式**和**非FP-strict模式**。方法的浮点模式决定于class文件中代表该方法的method_info结构的访问标志(access_flags)中的ACC_STRICT标志位。为真，则方法的浮点模式是FP-strict，否则是非FP-strict模式。  
提及操作数栈或字节码指令具有某种浮点模式，指的都是对应的方法所具备的浮点模式。  
在Java虚拟机实现单精度指数扩展集合或双精度指数扩展集合时才会关注浮点模式，其他情况下float和double两种浮点类型都分别限于单精度和双精度浮点数集合之中。尤其是，类和实例的字段、数组元素、本地变量和方法参数的取值范围都限于标准的数值集合之中。  

### 6.3 数值集合转换
在一些特定场景下，支持扩展指数集合的Java虚拟机实现数值在标准浮点数集合与扩展指数集合至今啊的映射关系是允许或必要的，这种映射操作称为**数值集合转换**。数值集合转换并非数据类型转换，而是在同一种数据类型的不同数据集合之间进行映射。  
数值集合转换不改变正负无穷和NaN，而且也不能改变待转换数值的符号，对于非浮点类型的数值，数值集合转换无效。  

## 7. 特殊方法
在Java虚拟机层面上，Java编程语言中的构造器是以一个名为&lt;init&gt;的特殊**实例初始化方法**的形式出现的，方法名称由编译器命名的非合法的Java方法名字，不可能通过程序编码的方式实现。实例初始化方法只能在实例的初始化期间，通过Java虚拟机的*invokespecial*指令来调用，而且只能在尚未初始化的实例上调用该指令。构造器的访问权限，也会约束由该构造器所衍生出来的实例初始化方法。  
一个类或接口最多可以包含不超过一个**类或接口的初始化方法**，是一个不包含参数的、返回类型为void的方法，名称&lt;clinit&gt;。在class文件的版本号不小于51.0时，&lt;clinit&gt;方法必须设置ACC_STATIC标志才能成为类或接口的初始化方法。该方法也是编译器命名的非合法Java方法名字，不可能通过Java程序编码的方式直接实现。类或接口的初始化方法由Java虚拟机自身隐藏调用，没有任何虚拟机字节码指令可调用，只会在类的初始化阶段中由虚拟机自身调用。  
当一个方法具有**签名多态性**(signature polymorphic)，则方法满足以下全部条件：  
+ 通过java.lang.invoke.MethodHandle类进行声明。  
+ 只有一个类型为Object[]的形参。  
+ 返回值为Object。  
+ 设置了ACC_VARARGS和ACC_NATIVE标志。  

在Java SE 8中，只有java.lang.invoke.MethodHandle的invoke和invokeExact是签名多态性方法。  
在Java SE8中，*invokevirtual*指令对具有签名多态性的方法进行特殊处理，以保证方法句柄能够正常调用。方法句柄是一种可以直接运行的强类型引用，可指向相关的方法、构造器、字段或者其他低级操作，并具有参数或返回值转换能力。转换能力可以对原方法执行转化、插入、删除及替换等形式的变换。  

## 8. 异常
Java虚拟机里面的异常使用Throwable或其子类的实例来表示，抛出异常的本质是程序控制权的一种即时的、非局部的转换——从异常抛出的地方转换至处理异常的地方。  

异常分为同步异常和异步异常。由于当前线程执行的某个操作所导致的异常称为同步异常，占异常的绝大多数。异步异常可以在程序执行过程中随时发生。异常出现的原因分为三种：  
+ *athrow*字节码指令被执行  
+ 虚拟机同步检测到程序发生了非正常的执行情况，异常必将紧接着在发生非正常执行情况的字节码指令之后抛出  
+ 异步异常出现的原因：  
   - 调用了Thread或者ThreadGroup的stop方法。当某个线程调用了stop方法时，会影响到其他线程或在特定线程组中的所有线程。这时候其他线程中出现的异常就是异步异常，因为这些异常可能出现在线程执行过程中的任何位置。  
   - Java虚拟机实现发生了内部错误。  

Java虚拟机规范允许在异步异常抛出之前额外执行一小段有限的代码，使得代码优化器能够在不违反Java语言语义的前提下检测并把这些异常在可处理他们的地方抛出。  

抛出异常的动作在Java虚拟机中有精确的定义：当异常抛出、程序控制权发生转移的那一刻，所有在异常抛出位置之前的字节码指令所产生的影响都应当是可以观察到的，而在异常抛出的位置之后的字节码指令，则不应当产生执行效果。如果虚拟机执行的代码是优化后的代码，有一些在异常出现位置之后的代码可能已经执行了，这些代码必须保证被它们提前执行所产生的影响对用户程序来说是不可见的。  

 由Java虚拟机执行的每个方法都会配有零个至多个**异常处理器**。异常处理器描述了其在方法代码中的有效作用范围（通过字节码偏移量范围来描述）、能处理的异常类型及处理异常的代码所在位置。  
 当抛出异常时，Java虚拟机搜索当前方法包含的各个异常处理器，如果能找到可以处理该异常的异常处理器，则将代码控制权转向异常处理器中描述的处理异常的分支之中。如果当前方法中没有找到任何异常处理器，即方法调用异常完成的情况，当前方法的操作数栈和局部变量表都将被丢弃，虽有对应的栈帧出栈并回复到该方法调用者的栈帧中。未被处理的异常将在方法调用者的栈帧中重新抛出，并在整个方法调用链里不断重复进行前面描述的处理过程。如果已经到达方法调用链的顶端，却还没有找到合适的异常处理器去处理异常，整个执行线程都将被终止。  
 
异常处理器的搜索顺序很关键，在class文件里面，每个方法的异常处理器都存储在一个表中。在运行时，当有异常抛出之后，Java虚拟机按照class文件中异常处理器表描述的异常处理器的先后顺序，从前至后进行搜索。Java虚拟机本身不会对方法的异常处理器表进行排序或其他方式强制处理。只有在class文件中定义了明确的异常处理器查找顺序，才能保证无论class文件是通过何种途径产生的，Java虚拟机执行时都能有一致的行为表现。    


## 9. 字节码指令集简介

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的**操作码**(opcode)和跟随其后的零至多个代表此操作所需参数的**操作数**(operand)所构成。操作数的数量及长度取决于操作码，如果一个操作数的长度超过了一个字节，将会以*big-endian**顺序存储，即高位在前的字节序。  
字节码指令流应当都是单字节对齐的，只有*tableswitch*和*lookupswitch*两个指令例外。由于它们的操作数比较特殊，都是以4字节为界划分的，所以当两个指令的参数位置不是4字节的倍数时，需要预留相应的空位补全到4字节的倍数以实现对齐。  

### 9.1 数据类型与Java虚拟机

在Java虚拟机的指令集中，大多数的指令都包含了其所操作的数据类型信息。  
+ 对于大部分与数据类型相关的字节码指令来说，操作码助记符中特殊的字符表明该指令为哪种数据类型服务  
   *i*代表int类型的数据操作，*l*代表long，*s*代表short，*b*代表byte，*c*代表char，*f*代表float，*d*代表double，*a*代表reference  
+ 部分指令的助记符没有明确用字母指明数据类型  
   *arraylength*指令没有代表数据类型的特殊字符，但操作数只能是一个数组类型的对象  
+ 与数据类型无关的指令，如*goto*

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# Java虚拟机 

> Java虚拟机与Java语言并没有必然的联系，只与特定的二进制文件格式——class文件格式所关联。class文件包含了Java虚拟机指令集（或称为字节码）和符号表，以及其他一些辅助信息。  
基于安全方面的考虑，Java虚拟机在class文件中施加了许多强制性的语法和结构化约束，凡是能够用class文件正确表达出来的编程语言，都可以放在Java虚拟机中执行。  

## 1. class文件格式
编译后被Java虚拟机执行的代码使用了一种平台中立（不依赖于特定硬件及存储设备）的二进制格式来表示，
并且经常以文件的形式存储，这种格式称为class文件格式。  
class文件格式中精确地定义了类与接口的表示形式，包括在平台相关的目标文件格式中一些细节的惯例。

## 2. 数据类型
编译器应当在编译期间尽最大努力完成可能的类型价差，使得虚拟机在运行期间无需进行这些操作。  
Java虚拟机的数据类型分为两类：  
1. 原始类型(primitive type)  
Java虚拟机所支持的原始数据类型那个包括**数值类型**、boolean类型和returnAddress类型。
   + 数值类型  
     分为**整数类型**和**浮点类型**。  
       - 整数类型
       
         | 类型 | 取值范围 | 描述 |
         | :---: | :--- | --- | 
         | byte   | -128 ~ 128  (-2<sup>7</sup> ~ 2<sup>7</sup>-1) | 值为8位有符号二进制补码整数，默认为零。    | 
         | short  | -32768 ~ 32767  (-2<sup>15</sup> ~ 2<sup>15</sup>-1) | 值为16位有符号二进制补码整数，默认值为零。  |
         | int    | -2<sup>31</sup> ~ 2<sup>31</sup>-1 | 值为32位有符号二进制补码整数，默认值为零。  |
         | long   | -2<sup>63</sup> ~ 2<sup>63</sup>-1 | 值为64位有符号二进制补码整数，默认值为零。  |
         | char   | 0 ~ 65535 | 值为16位无符号整数表示，指向基本多文种平面(BMP)的Unicode码点，以UTF-16编码，默认值为Unicode的null码点（'/u0000''）。 |
       - 浮点类型    
              
         | 类型 | 描述 |
         | :---: | --- | 
         | float | 值为单精度浮点数集合或单精度浮点扩展指数集合中的元素，默认值为正数0。 |  
         | double | 值为双精度浮点数集合或双精度扩展指数集合中的元素，默认值为正数0。 |  
         
         任何一个非零的、可数的任意浮点值都可以表示为s\*m\*2<sup>e-N+1</sup>，其中s可以是+1或者-1，m是一个小于2<sup>N</sup>的正整数，e是一个介于E<sub>min</sub>=-(2<sup>K-1</sup>-2)和E<sub>max</sub>=2<sup>K-1</sup>-1之间的整数。部分浮点数使用这种规则得到的表达形式可能不是唯一的。分为*标准表示*、*非标准表示*和*非标准值*。  
         **表2-1 浮点数集合的参数**  
         
         | 参数 | 单精度浮点数集合 | 单精度扩展指数集合 | 双精度浮点数集合 | 双精度扩展指数集合 |
         | --- | ------------- | --------------- | ------------- | --------------- |
         | N | 24 | 24 | 53 | 53 |
         | K | 8 | &gt;= 11 | 11 | &gt;= 15 |
         | E<sub>max</sub> | +127 | &gt;=+1023 | +1023 | &gt;=+16383 |
         | E<sub>min</sub> | -126 | &lt;=-1022 | -1022 | &lt;=-16382 |  
         
         上述四种集合都不仅包含可数的非零值，而且包含5个特殊的数值：正数零、负数零、正无穷大、负无穷大和NaN。  
         表2-1中的约束经过精心设计，保证每一个单精度浮点数集合中的元素都一定是单精度扩展指数集合、双精度浮点数集合和双精度扩展指数集合中的元素。
         同时，每一个双精度浮点数集合中的元素都一定是双精度扩展指数集合的元素。  
         NaN是无序的，只要操作数是NaN，那么对它进行任何数值比较和等值测试都会返回false。值得一提的是，有且只有NaN这一个数在与自身比较是否等值时会得到false。
         任何数字与NaN进行不等值比较都会返回true。
   + boolean类型  
     值为布尔值true和false，默认值为false。  
     Java虚拟机对boolean类型提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字J节码指令，Java语言表达式所操作的boolean值，在编译后都使用Java虚拟机中的int数据类型代替。   
     Java虚拟机直接支持boolean类型的数组，虚拟机的*newarray*指令可以创建这种数组。boolean类型数组的访问与修改共用byte类型数组的baload和bastore指令。  
     Java虚拟机会把boolean数组元素中的true值采用1来表示，false值采用0来表示，当Java编译器把Java语言中的boolean类型值映射为Java虚拟机的int类型时，必须采用上述表示方式。  
   + returnAddress类型  
     指向某个操作码的指针，此操作码与Java虚拟机指令相对应。在虚拟机支持的所有原始类型中，只有returnAddress类型是不能直接与Java语言的数据类型相对应的。无法在程序运行期间更改。
2. 引用类型(reference type)  
 Java虚拟机中有三种引用类型：**类类型(class type)**、**数组类型(array type)**和**接口类型(interface type)**。这些引用类型的值分别指向动态创建的类实例、数组实例和实现了某个接口的类实例或数组实例。  
 数组类型最外面的一维元素的类型，叫做该数组类型的**组件类型(component type)**。当迭代到组件类型不是数组时的类型称为本数组的**元素类型(element type)**。数组的元素类型必须是原生类型、类类型或接口类型之一。  
 引用类型的值中，有一个特殊的值：**null**，当一个引用不指向任何对象的时候，它的值就用null来表示。一个为null的引用，起初不具备任何实际的运行期类型，但可转型为任意的引用类型。引用类型的默认值就是null。  
 Java虚拟机规范并没有规定null在虚拟机实现中应当怎样用编码来表示。  
 
## 3. 运行时数据区 
 Java虚拟机定义了若干程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动和退出而创建或销毁。另外一些则是与线程一一对应的，会随着线程开始和结束而创建和销毁。  
 
### 3.1 pc寄存器
 Java虚拟机可支持多条线程同时执行，每一条线程都由自己的pc(program counter)寄存器。在任意时刻，一条线程只会执行一个方法的代码，称为该线程的当前方法。
 如果方法是native的，那么pc寄存器的值是undefined；如果方法不是native的，那么pc寄存器保存Java虚拟机正在执行的字节码指令的地址。
 pc寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。  

### 3.2 Java虚拟机栈
 每一条Java虚拟机线程都有自己私有的J**ava虚拟机栈**(Java Virtual Machine stack)。栈与线程同时创建，用于存储栈帧。作用：  
 + 存储局部变量与一些尚未算好的结果。  
 + 在方法调用和返回中担任重要角色。  
 
 因为除了栈帧的出栈和入栈之外，Java虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配。
 Java虚拟机栈所使用的内存不需要保证是连续的。  
 Java虚拟机规范允许Java虚拟机栈被实现成固定大小，也允许根据计算动态来扩展和收缩。采用固定大小的Java虚拟机栈时，
 每个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，应提供调节虚拟机栈初始容量的手段。对于动态扩展和收缩Java虚拟机栈，
 应当提供调节最大、最小容量的手段。  
 
 Java虚拟机栈可能发生如下异常情况：  
 + 如果线程请求分配的栈容量超出Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。
 + 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，Java虚拟机将会抛出一个OutOfMemoryError异常。
 
### 3.3 Java堆
 在Java虚拟机中，**堆**(heap)是可供所有线程共吸纳的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。  
 Java堆在虚拟机启动的时候就被创建，存储了被自动内存管理系统（即GC）所管理的各种对象，这些受管理的对象无需也无法显式地销毁。规范中未规定相关具体技术实现自动内存管理技术，
 虚拟机实现者可以根据系统根据系统的实际需要选择。  
 Java堆的容量可以是固定的，也可以随着承训执行的需求动态扩展或收缩，应提供调节初始容量或最大最小容量的手段。Java堆使用的内存不需要保证是连续的。  
 
 Java堆可能发生如下异常情况：  
 + 如果实际所需的堆超过了自动内存管理系统能提供的最大容量，Java虚拟机会抛出一个OutOfMemoryError异常。  
 
### 3.4 方法区
 在Java虚拟机中，**方法区**(method area)是可供各个线程共享的运行时内存区域。作用：  
 + 存储了每一个类的结构信息。  
 
 方法区在系统启动的时候创建，虽然方法区是堆的逻辑组成部分，但简单的虚拟机实现可选择在这个区域不是先垃圾收集与压缩。规范中未规定相关具体技术实现自动内存管理技术。  
 方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展或收缩，应提供调节初始容量或最大最小容量的手段。方法区在实际内存空间中可以是不连续的。  
 
 方法区可能发生如下异常情况：  
 + 如果方法区的内存空间不能满足内存分配请求，那么Java虚拟机将抛出一个OutOfMemoryError异常。  
 
### 3.5 运行时常量池
 **运行时常量池**(running constant pool)是class文件中每一个类或接口的常量池表的运行时表示形式，
 它包括了若干种不同的常量，从编译期可知的数值字面量到必须在运行期解析后才能获得的方法或字段引用。  
 每一个运行时常量池都在Java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。  
 
 在创建类和接口的运行时常量池时，可能会发生如下异常情况：  
 + 当创建类或接口时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，那么Java虚拟机将会抛出
 一个OutOfMemoryError异常。  

### 3.6 本地方法栈
 Java虚拟机实现可能会使用到传统的栈（通常称为C stack）来支持native方法的执行，这个栈称为
 **本地方法栈**(native method stack)。当Java虚拟机使用其他语言来实现指令集解释器时，
 也可以使用本地方法栈。如果支持本地方法栈，一般会在线程创建的时候按线程分配。  
 Java虚拟机规范允许本地方法栈实现成固定大小或根据计算来动态扩展和收缩，应提供调节初始容量
 或最大最小容量的手段。如果采用固定大小的本地方法栈，那么每一个线程的本地方法栈容量可以在
 创建栈的时候独立选定。  
 
 本地方法栈可能发生如下异常情况：  
 + 如果本地方法栈请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个
 StackOverflowError异常。  
 + 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程
 时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。  
 
## 4. 栈帧
 **栈帧**(frame)是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接、方法返回值
和异常分派。  
 栈帧随着方法调用而创建，随着方法结束而销毁（正常或异常）。栈帧的存储空间有创建它的线程分配在
Java虚拟机栈之中，每个栈帧都有本地变量表(local var3iab**le)、操作数栈(operand stack)和指
向当前方法所属的类的运行时常量池的引用。  
 本地变量表和操作数栈的容量在编译期确定，并通过相关方法的code属性保存及提供给栈帧使用。因此，
栈帧数据结构的大小仅仅取决于Java虚拟机的实现。实现者可以在调用方法时分配内存。  
 在线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的，称为**当前栈帧**
(current frame)。这个栈帧对应的方法称为**当前方法**(current method)，定义当前方法的
类称作**当前类**(current class)。调用新方法时，新的栈帧会随之创建，并随着程序控制权移交
到新方法而成为当前栈帧。方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，并丢弃当前
栈帧，使得前一个栈帧重新成为当前栈帧。  
 
### 4.1 局部变量表
 每个栈帧内部都包含一组称为局部变量表的变量列表。栈帧中局部变量表的长度由编译期决定，并存储于
类或接口的二进制表示之中，即通过方法的code属性保存及提供给栈帧使用。  
 一个局部变量可保存一个类型为boolean、byte、char、short、int、float、reference或returnAddress
的数据。两个局部变量可以保存一个类型为long或double的数据。  
 局部变量使用索引来定位访问。long和double类型的数据占用两个连续的局部变量，采用其中较小的索
引来定位。  
 Java虚拟机使用局部变量表来完成方法调用时的参数传递。当调用类方法时，方法的参数会依次传递到
局部变量表中从0开始的连续位置上。当调用实例方法时，第0个局部变量一定用来存储该实例方法所在
对象的引用（即Java语言中的this关键字），后续的其他参数会传递至局部变量表中从1开始的连续位
置上。  

### 4.2 操作数栈
每个栈帧内部都包含一个称为**操作数栈**的后进先出(LIFO)栈。栈帧中操作数栈的深度由编译期决定，并且
通过方法的code属性保存及提供给栈帧使用。  
栈帧在刚创建时，操作数栈是空的。Java虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制
常量或变量值到操作数栈中，也提供了一些指令用于从操作数栈取走数据、操作数据及把操作结果重新入栈。在
调用方法时，操作数栈也用来准备调用方法的参数以及接受方法返回的结果。  
操作数栈的每个位置上都可以保存一个Java虚拟机中定义的任意数据类型的值，包括long和double类型。  
在操作数栈中的数据必须正确地操作。有一小部分Java虚拟机指令可以不关注操作数的具体类型，把所有在运行
时数据区中的数据当作裸类型数据来操作，这些操作不能修改数据或拆散不可拆分的数据，操作的正确性通过class
文件的校验过程来强制保障。  
在任意时刻，操作数栈都会有一个确定的栈深度，一个long或double类型的数据会占用两个单位的栈深度，其他
数据类型会占用一个单位的栈深度。  

### 4.3 动态链接
每个栈帧内部都包含一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现**动态链接**。
在class文件里面，一个方法若要调用其他方法或访问成员变量，则需要通过符号引用来表示，动态链接的作用就是
将这些符号引用所表示的方法转换为对实际方法的直接引用。类加载的过程中将要解析尚未被解析的符号引用，并且
将对变量的访问转化为变量的访问转化为变量在程序运行时，位于存储结构中的正确偏移量。  
由于对其他类中的方法和变量进行了晚期绑定，所以即便类发生变化也不会影响调用他们的方法。  

## 4.4 方法调用正常完成  
方法调用正常完成是指在方法的执行过程中，没有抛出任何异常。如果当前方法调用正常返回，很可能会返回一个值
给调用它的方法。方法正常完成发生在一个方法执行过程中遇到了方法返回的字节码指令时，使用哪种返回指令取决
于方法返回值的数据类型（如果有返回值）。当前栈帧承担着恢复调用者状态的责任，包括恢复调用者的局部变量表
和操作数栈，以及正确递增程序计数器，以跳过刚才执行的方法调用指令等。调用者的代码在被调用方法的返回值压
入调用者栈帧的操作数栈后，会继续正常执行。  

## 4.5 方法调用异常完成
方法调用异常完成是指在方法的执行过程中，某些指令导致了Java虚拟机抛出了异常，并且虚拟机抛出的异常在该方
法中没有办法处理，或者在执行过程中遇到athrow字节码指令并显式地抛出异常，同时在该方法内部没有捕获异常。
如果方法异常调用完成，那一定不会有方法返回值返回给调用者。  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
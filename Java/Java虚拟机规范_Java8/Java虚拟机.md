# Java虚拟机 

> Java虚拟机与Java语言并没有必然的联系，只与特定的二进制文件格式——class文件格式所关联。class文件包含了Java虚拟机指令集（或称为字节码）和符号表，以及其他一些辅助信息。  
基于安全方面的考虑，Java虚拟机在class文件中施加了许多强制性的语法和结构化约束，凡是能够用class文件正确表达出来的编程语言，都可以放在Java虚拟机中执行。  

## 1. class文件格式
编译后被Java虚拟机执行的代码使用了一种平台中立（不依赖于特定硬件及存储设备）的二进制格式来表示，
并且经常以文件的形式存储，这种格式称为class文件格式。  
class文件格式中精确地定义了类与接口的表示形式，包括在平台相关的目标文件格式中一些细节的惯例。

## 2. 数据类型
编译器应当在编译期间尽最大努力完成可能的类型价差，使得虚拟机在运行期间无需进行这些操作。  
Java虚拟机的数据类型分为两类：  
1. 原始类型(primitive type)  
Java虚拟机所支持的原始数据类型那个包括**数值类型**、boolean类型和returnAddress类型。
   + 数值类型  
     分为**整数类型**和**浮点类型**。  
       - 整数类型
       
         | 类型 | 取值范围 | 描述 |
         | :---: | :--- | --- | 
         | byte   | -128 ~ 128  (-2<sup>7</sup> ~ 2<sup>7</sup>-1) | 值为8位有符号二进制补码整数，默认为零。    | 
         | short  | -32768 ~ 32767  (-2<sup>15</sup> ~ 2<sup>15</sup>-1) | 值为16位有符号二进制补码整数，默认值为零。  |
         | int    | -2<sup>31</sup> ~ 2<sup>31</sup>-1 | 值为32位有符号二进制补码整数，默认值为零。  |
         | long   | -2<sup>63</sup> ~ 2<sup>63</sup>-1 | 值为64位有符号二进制补码整数，默认值为零。  |
         | char   | 0 ~ 65535 | 值为16位无符号整数表示，指向基本多文种平面(BMP)的Unicode码点，以UTF-16编码，默认值为Unicode的null码点（'/u0000''）。 |
       - 浮点类型    
              
         | 类型 | 描述 |
         | :---: | --- | 
         | float | 值为单精度浮点数集合或单精度浮点扩展指数集合中的元素，默认值为正数0。 |  
         | double | 值为双精度浮点数集合或双精度扩展指数集合中的元素，默认值为正数0。 |  
         
         任何一个非零的、可数的任意浮点值都可以表示为s\*m\*2<sup>e-N+1</sup>，其中s可以是+1或者-1，m是一个小于2<sup>N</sup>的正整数，e是一个介于E<sub>min</sub>=-(2<sup>K-1</sup>-2)和E<sub>max</sub>=2<sup>K-1</sup>-1之间的整数。部分浮点数使用这种规则得到的表达形式可能不是唯一的。分为*标准表示*、*非标准表示*和*非标准值*。  
         **表2-1 浮点数集合的参数**  
         
         | 参数 | 单精度浮点数集合 | 单精度扩展指数集合 | 双精度浮点数集合 | 双精度扩展指数集合 |
         | --- | ------------- | --------------- | ------------- | --------------- |
         | N | 24 | 24 | 53 | 53 |
         | K | 8 | &gt;= 11 | 11 | &gt;= 15 |
         | E<sub>max</sub> | +127 | &gt;=+1023 | +1023 | &gt;=+16383 |
         | E<sub>min</sub> | -126 | &lt;=-1022 | -1022 | &lt;=-16382 |  
         
         上述四种集合都不仅包含可数的非零值，而且包含5个特殊的数值：正数零、负数零、正无穷大、负无穷大和NaN。  
         表2-1中的约束经过精心设计，保证每一个单精度浮点数集合中的元素都一定是单精度扩展指数集合、双精度浮点数集合和双精度扩展指数集合中的元素。
         同时，每一个双精度浮点数集合中的元素都一定是双精度扩展指数集合的元素。  
         NaN是无序的，只要操作数是NaN，那么对它进行任何数值比较和等值测试都会返回false。值得一提的是，有且只有NaN这一个数在与自身比较是否等值时会得到false。
         任何数字与NaN进行不等值比较都会返回true。
   + boolean类型  
     值为布尔值true和false，默认值为false。  
     Java虚拟机对boolean类型提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字J节码指令，Java语言表达式所操作的boolean值，在编译后都使用Java虚拟机中的int数据类型代替。   
     Java虚拟机直接支持boolean类型的数组，虚拟机的*newarray*指令可以创建这种数组。boolean类型数组的访问与修改共用byte类型数组的baload和bastore指令。  
     Java虚拟机会把boolean数组元素中的true值采用1来表示，false值采用0来表示，当Java编译器把Java语言中的boolean类型值映射为Java虚拟机的int类型时，必须采用上述表示方式。  
   + returnAddress类型  
     指向某个操作码的指针，此操作码与Java虚拟机指令相对应。在虚拟机支持的所有原始类型中，只有returnAddress类型是不能直接与Java语言的数据类型相对应的。无法在程序运行期间更改。
2. 引用类型(reference type)  
 Java虚拟机中有三种引用类型：**类类型(class type)**、**数组类型(array type)**和**接口类型(interface type)**。这些引用类型的值分别指向动态创建的类实例、数组实例和实现了某个接口的类实例或数组实例。  
 数组类型最外面的一维元素的类型，叫做该数组类型的**组件类型(component type)**。当迭代到组件类型不是数组时的类型称为本数组的**元素类型(element type)**。数组的元素类型必须是原生类型、类类型或接口类型之一。  
 引用类型的值中，有一个特殊的值：**null**，当一个引用不指向任何对象的时候，它的值就用null来表示。一个为null的引用，起初不具备任何实际的运行期类型，但可转型为任意的引用类型。引用类型的默认值就是null。  
 Java虚拟机规范并没有规定null在虚拟机实现中应当怎样用编码来表示。  
 
## 3. 运行时数据区 
 Java虚拟机定义了若干程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动和退出而创建或销毁。另外一些则是与线程一一对应的，会随着线程开始和结束而创建和销毁。  
 
### pc寄存器
 Java虚拟机可支持多条线程同时执行，每一条线程都由自己的pc(program counter)寄存器。在任意时刻，一条线程只会执行一个方法的代码，称为该线程的当前方法。
 如果方法是native的，那么pc寄存器的值是undefined；如果方法不是native的，那么pc寄存器保存Java虚拟机正在执行的字节码指令的地址。
 pc寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。  

### Java虚拟机栈
 每一条Java虚拟机线程都有自己私有的J**ava虚拟机栈**(Java Virtual Machine stack)。栈与线程同时创建，用于存储栈帧。作用：  
 + 存储局部变量与一些尚未算好的结果。  
 + 在方法调用和返回中担任重要角色。  
 因为除了栈帧的出栈和入栈之外，Java虚拟机栈不会再受其他因素的影响，所以栈帧可以在堆中分配。
 Java虚拟机栈所使用的内存不需要保证是连续的。  
 Java虚拟机规范允许Java虚拟机栈被实现成固定大小，也允许根据计算动态来扩展和收缩。
 采用固定大小的Java虚拟机栈时，每个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，应提供调节虚拟机栈初始容量的手段。
 对于动态扩展和收缩Java虚拟机栈，应当提供调节最大、最小容量的手段。  
 Java虚拟机栈可能发生如下异常情况：  
 + 如果线程请求分配的栈容量超出Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。
 + 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，Java虚拟机将会抛出一个OutOfMemoryError异常。
 
### Java堆
 在Java虚拟机中，**堆**(heap)是可供所有线程共吸纳的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
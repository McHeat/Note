# 消息中间件
## 为什么使用MQ

+ 异步
+ 解耦
+ 削峰填谷

## 使用MQ的优缺点

+ 优点同上
+ 缺点
  - 系统可用性降低
  - 系统复杂度提高
  - 数据一致性问题

## 如何保证MQ消息不丢失

+ 生产者丢失
  - **事务机制**：通过`channel.txSelect`、`channel.txCommit`、`channel.txRollback`来开启事务，同步操作导致了生产者的吞吐量和性能降低。
  - **confirm机制**：通过RabbitMQ的回调ack接口、nack接口来确定消息是否已处理。
+ RabbitMQ丢失  
  RabbitMQ提供了**持久化**机制，消息写入后会持久化到磁盘：
  - 创建queue时设置为持久化的，保证rabbitmq持久化queue元数据
  - 发送消息时将消息的deliveryMode设置为2，将小关系持久化到磁盘
+ 消费者丢失  
  RabbitMQ消费消息的机制：在消费者收到消息时，发送一个ack给RabbitMQ，告诉这条消息已被消费到，然后RabbitMQ会删除消息。  
  默认情况下，发送ack操作是自动提交的，在消费者一收到消息就会自动返回ack给RabbitMQ，所以会出现丢消息的问题。  
  解决方案是：关闭RabbitMQ消费者的自动提交ack，在消费者处理完消息之后再手动提交ack。  

## 如何保证MQ的高可用性
RabbitMQ有三种模式：**单机模式**、**普通集群模式**、**镜像集群模式**。  

+ 单机模式  
  demo级别，存在单点问题
+ 普通集群模式  
  在多台机器启动多个rabbitmq实例，类似master-slave模式。创建的queue仅存在一个master的rabbitmq实例，其他实例都同步接收消息的RabbitMQ元数据。当消费者消费时，如果连接的RabbitMQ实例不是存放Queue数据的实例，会去对应的实例上拉取数据然后返回给客户端。  
  这种方式在连接到不是存放queue数据的实例，会造成额外的性能开销。从放Queue的实例来去会导致单实例性能瓶颈，且宕机导致其他实例无法拉取数据。该方案主要用于提高吞吐量。  
+ 镜像集群模式  
  镜像集群模式创建的queue、无论元数据还是queue里的消息都会存在于多个实例上，每次写消息到queue时都会自动同步到多个实例的queue。  
  存在的缺陷：  
  - 性能开销过高：消息需要同步所有机器，导致网络带宽压力和消耗很重
  - 扩展性低：无法解决某个queue数据量特别大的情况，导致queue无法线性拓展










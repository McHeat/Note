# 2. Service Discovery: Eureka Server #

## 2.1 How to Include Eureka Server ##
要想在你的程序中涵盖Eureka Server需使用以下方法：group语句  `org.springframework.cloud`开头，以及artifact id `spring-cloud-starter-netflix-eureka-server`。查看 [Spring Cloud Project page](https://projects.spring.io/spring-cloud/) 获取更多信息，以使用当前的Spring Cloud Release Train设置你的编译系统（build system）。

## 2.2 How to Run a Eureka Server ##

例子：
```java
 @SpringBootApplication
 @EnableEurekaServer
 public class Application {
    
    public static void main(String[] args) {
        new SpringApplicationBuilder(Application.class).web(true).run(args);
    }
 }
```
服务器具有可视化的主页, 以及在`/eureka/*`下Eureka每个标准功能对应的HTTP API端点。
Eureka 背景阅读:  [flux capacitor](https://github.com/cfregly/fluxcapacitor/wiki/NetflixOSS-FAQ#eureka-service-discovery-load-balancer) 和 [google group discussion](https://groups.google.com/forum/?fromgroups#!topic/eureka_netflix/g3p2r7gHnN0)。

> 由于Gradle依赖性解决原则以及父类bom特性的缺失,简单依赖spring-cloud-starter-netflix-eureka-server可能引起程序启动失败。 
> 为弥补这种情况，必需添加Spring Boot Gradle插件，并且 Spring cloud starter父类bom必须以下述方式导入:
>
> **build.gradle**
> ```groovy
>    buildscript {
>      dependencies {
>         classpath("org.springframework.boot:spring-boot-gradle-plugin:1.5.10.RELEASE")
>      }
>    }
>    
>    apply plugin: "spring-boot"
>    
>    dependencyManagement {
>      imports {
>         mavenBom "org.springframework.cloud:spring-cloud-dependencies:Edgware.SR2"
>      }
>    }
> ``` 
>
## 2.3 High Availability, Zones and Regions ##
Eureka服务端不具有后端储存（backend store），但是在注册中心的服务实例都必须发送心跳，用以使他们的注册数据保持最新（因此Eureka server可以在内存中处理）。
Clients也具有eureka注册信息的缓存（in-memory cache）（因此对于服务的单次请求不必每次都访问注册中心）。
默认每个Eureka服务器同时也是Eureka客户端，并且需要（至少一个）服务URL来定位对等点。
如果不提供URL，服务器也会运行工作，但是会输出不能注册到对等点的大量日志。

查看[below for details of Ribbon support](https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.4.4.RELEASE/multi/multi_spring-cloud-ribbon.html)  Zones and Regions.

## 2.4 Standalone Mode ##
客户端和服务端的双重缓存的结合以及心跳机制会使Eureka服务端能够有效从失败中恢复，只要有部分监控或弹性运行时间来维持（如Cloud Foundry）。
在独立模式下，你会倾向于关闭客户端的行为，这样就不需要一直去尝试但无法到达对等点（peer）。例如：
**application.yml (Standalone Eureka Server)**
```yaml
 server:
   port: 8761
 
 eureka:
   instance:
     hostname: localhost
   client:
     registerWithEureka: false
     fetchRegistry: false
     serviceUrl:
       defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/`
```
 注意，`serviceUrl`作为本地实例指向同一主机名称。

## 2.5 Peer Awareness ##
通过运行多重实例及实例互相注册可以使Eureka更有弹性及可用性。事实上，这是默认行为，
你需要做的只是给对等点添加有效的`serviceUrl`，例如：

**application.yml (Two Peer Aware Eureka Servers)**
```yaml

 ---
 spring:
   profiles: peer1
 eureka:
   instance:
 hostname: peer1
   client:
 serviceUrl:
   defaultZone: http://peer2/eureka/
 
 ---
 spring:
   profiles: peer2
 eureka:
   instance:
 hostname: peer2
   client:
 serviceUrl:
   defaultZone: http://peer1/eureka/
```
此例中含有一个YAML文件，可以在2个主机(peer1 and peer2)中通过不同的Spring profiles运行同样的服务。可以使用这种构架来检测单个主机中的peer awareness（不需要很多数据），通过操控`/etc/hosts`来解析主机名。
事实上，如果程序在已知主机名的机器中运行，`eureka.instance.hostname`不是必须的（默认使用`java.net.InetAddress`来查询）。
只要单边能够互相联系，就可以给系统附加多重peers，就可在彼此间同步注册信息。
如果peers是物理上隔离（在一个数据中心或多个数据中心中），那么系统原则上可以在split-brain式失效（ split-brain type failures）中幸存。

## 2.6 Prefer IP Address ##
一些情况下，对Eureka来说，公告服务器的IP而非hostname更可取。设置`eureka.instance.preferIpAddress`为`true`，当程序向eureka注册时，会使用IP而非hostname。


如果Java并不能决定hostname, IP会被发送给Eureka。只能通过 `eureka.instance.hostname`来设置hostname。 在运行时使用环境变量来设置hostname，例如：`eureka.instance.hostname=${HOST_NAME}`。

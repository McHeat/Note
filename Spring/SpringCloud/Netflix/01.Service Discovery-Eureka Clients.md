# 1. Service Discovery: Eureka Clients

 服务发现是微服务架构的关键原则之一。尝试手动或约定方式配置每个客户端非常困难且脆弱。Eureka是Netflix服务发现的服务器与客户端。Eureka服务器能够通过配置和扩展提高可用性，每个服务器的注册状态复制给其他服务器。

## 1.1 How to Include Eureka Client ##

 通过groupId `org.springframework.cloud` 以及artifactId `spring-cloud-starter-netflix-eureka-client` 来引入。
 查看 [Spring Cloud Project](https://projects.spring.io/spring-cloud/)来学习更多如何使用当前的Spring Cloud Release Train设置构建系统。

## 1.2 Registering with Eureka ##
 当客户端向Eureka注册时, 需要提供自身的元数据，例如：主机host、端口port、健康监控URL、主页等。
 Eureka从每个服务器的实例（instance）接收心跳消息。 如果心跳在配置时间内（configurable timetable）失败，此实例会被从注册服务器上移除。

 Eureka客户端示例(标准的SpringBoot应用):
 ```java
 @Configuration
 @ComponentScan
 @EnableAutoConfiguration
 @RestController
 public class Application {
    
    @RequestMapping("/")
    public String home() {
      return "Hello world";
    }
    
    public static void main(String[] args) {
      new SpringApplicationBuilder(Application.class).web(true).run(args);
    }
 }
 ```
 类路径中的 `spring-cloud-starter-netflix-eureka-client` 能使你的程序自动注册到Eureka服务器。Eureka服务器的地址需要配置，如在application.yml配置：
 ```yaml
 eureka:
  client:
   serviceUrl:
    defaultZone: http://localhost:8761/eureka/
 ```
 "defaultZone" 是一个神奇的字符串回馈值，为所有未配置指定服务器URL的客户端提供默认值。

 缺省程序名称(service ID), 虚拟主机（virtual host) 和非保护端口 （non-secure port）会从`Environment`中获取，分别是 `${spring.application.name}`、`${spring.application.name}` 和 `${server.port}`

在类路径中添加 `spring-cloud-starter-netflix-eureka-client` 可以使应用同时作为Eureka的实例(它会向服务器注册自身)和客户端(可通过服务器查询定位其他服务实例)。实例的行为由`eureka.instance.* `配置关键字驱动的, 如果程序具有` spring.application.name`属性(Eureka默认服务ID)也可使用这些默认值。

查看 [EurekaInstanceConfigBean](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java) 和 [EurekaClientConfigBean](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java) 以获取更详细的信息。

可通过设置 `eureka.client.enabled`为 `false`来禁止Eureka Discovery Client。

## 1.3 Authenticating with the Eureka Server ##
如果`eureka.client.serviceUrl.defaultZone`的URLs嵌入了验证信息，HTTP基本验证会自动添加到你的客户端(curl方式, 例如 `http://user:password@localhost:8761/eureka`)。更复杂的需求可以创建   `DiscoveryClientOptionalArgs`类型的`@Bean` 以及注入`ClientFilter`实例, 上述所有配置都会被应用于从客户端到服务器的调用。

> 由于Eureka的限制，每个服务器都执行基本验证是无法实现的，因此只有第一个发现的服务器会执行验证。

## 1.4 Status Page and Health Indicator ##
 Eureka实例的status page和health indicators分别默认为"/info" 和 "/health" ,是Spring Boot Actuator里可用端点的默认位置（default locations）。你需要替换这些, 即使Actuator application 使用的是非默认context 、servlet路径(e.g. `server.servletPath=/foo`)或者 管理节点路径(e.g. `management.contextPath=/admin`)。
实例:

**application.yml**
```yaml
eureka:
 instance:
  statusPageUrlPath: ${management.context-path}/info
  healthCheckUrlPath: ${management.context-path}/health
```
上述链接显示了被客户端clients使用的元数据，并且在一些场景中用于判断是否需要向程序发送请求, 因此准确指定这些信息将会非常有用。

## 1.5 Registering a Secure Application ##
如果你希望 app能够通过HTTPS连接，可以在`EurekaInstanceConfig`设置两个flags,分别是`eureka.instance.[nonSecurePortEnabled，securePortEnabled]=[false,true]` 。这样能使Eureka发布实例信息时明确指定使用安全通信。Spring Cloud 的`DiscoveryClient`会返回一个https开头的URI，并且本地Eureka实例信息会使用通信安全的health check的URL.

因为Eureka的内部工作机制, 在没有明确覆盖的情况下依然为status和home page发布非安全URL。能够使用占位符来配置eureka实例的url，例如：

**application.yml**
```yaml
eureka:
 instance:
  statusPageUrl: https://${eureka.hostname}/info
  healthCheckUrl: https://${eureka.hostname}/health
  homePageUrl: https://${eureka.hostname}/
```
(注意 `${eureka.hostname}` 是本地占位符，只可用在Eureka的后续版本.使用Spring 占位符可以实现相同的作用，例如使用`${eureka.instance.hostName}`)

> 如果你的app是由通过代理服务器（proxy）运行, 并且SSL终端也在该代理中(例如 ，作为服务运行在Cloud Foundry或其他平台)，那么需要确保该代理的`forwarded`报文头是被拦截的并且由程序可处理。在Spring Boot中内置的Tomcat 容器如果精确配置'X-Forwarded-\*`报文头，可以自动实现上述功能。典型错误是：该链接被你的程序释放到自身中(错误的host, 端口或协议)。

## 1.6 Eureka’s Health Checks ##

默认的，Eureka使用客户端心跳来决定客户端是否在线（up）。
未指定情况，Discovery Client不会普及每个Spring Boot Actuator应用的当前健康检查状态。也就意味着成功登记后，Eureka会一直声明该应用处于'UP'状态。
这种行为可以通过开启Eureka健康检测改变，从而上传程序状态给Eureka。这样，其他程序不会向非'UP'状态的程序发送流量。
**application.yml**
```yaml
eureka:
 client:
  healthcheck:
   enabled: true
```
>`eureka.client.healthcheck.enabled=true`只能被设置在**application.yml**中。在bootstrap.yml赋值会导致意想不到的副作用出现，如登记过的eureka出现`UNKNOWN `状态。

若需要控制健康检测, 可以考虑实现自定义`com.netflix.appinfo.HealthCheckHandler`。

## 1.7 Eureka Metadata for Instances and Clients ##
花费一些时间来了解 Eureka元数据的工作方式是很值得的, 如此你可以在自己的平台上做出一些有效的配置使用。
主机名称、IP地址、端口号、状态页和健康检查等都是一些标准元数据。这些元数据会发布到服务注册中，客户端通过它们与服务器直接联系。
其他元数据可附加在实例注册信息的`eureka.instance.metadataMap`属性中（这种方式同样适用于远程客户端）, 
但是一般来说在不了解到元数据的含义的情况下不会改变客户端的行为。 下面讲述了一些Spring Cloud已经指明作用的metadata map的特例。

### 1.7.1 Using Eureka on Cloudfoundry ###

Cloudfoundry具有全局路由，所以同一个应用的所有实例有相同的主机名称(其他相似架构的PaaS解决方案也是如此)。
如果你使用路由(依赖于你当前设置的平台强烈或强制性使用), 就需要明确设置主机名称和端口号(安全或非安全)。
你或许希望使用实例元数据来区别客户端实例(例如自定义的负载均衡器）。默认地，`eureka.instance.instanceId`同`vcap.application.instance_id`。
例如:

**application.yml**
```yaml
eureka:
  instance:
    hostname: ${vcap.application.uris[0]}
    nonSecurePort: 80
```
根据你的Cloudfoundry实例里规定的安全规则，你或许可以注册并且使用主机的IP地址来实现服务对服务的调用。
此方案暂时对Pivotal Web Services (PWS)中不可用.

### 1.7.2 Using Eureka on AWS ###

如果计划把程序AWS云平台配置, 那么Eureka实例将必须配置为AWS可用，可以通过如下方式定制EurekaInstanceConfigBean来实现:
```java
    @Bean
    @Profile("!default")
    public EurekaInstanceConfigBean eurekaInstanceConfig(InetUtils inetUtils) {
      EurekaInstanceConfigBean b = new EurekaInstanceConfigBean(inetUtils);
      AmazonInfo info = AmazonInfo.Builder.newBuilder().autoBuild("eureka");
      b.setDataCenterInfo(info);
      return b;
    }
```

### 1.7.3 Changing the Eureka Instance ID ###

一般地，Netflix的Eureka实例使用主机名称作为ID来注册(如每个主机都只有一个service)。Spring Cloud Eureka提供了一个更有意义的的系统默认值，
如下面所示: `${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}}`。
例如：`myhost:myappname:8080`。

使用Spring Cloud可以通过`eureka.instance.instanceId`设置唯一识别符来重写实例ID。例如:

**application.yml**
```yaml
eureka:
  instance:
    instanceId: ${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}
```
使用元数据, 当多个服务实例配置在localhost时, 随机值随之生效而使实例唯一。
在Cloudfoundry中，Spring Boot程序的`vcap.application.instance_id`会被自动填充, 因此随机值就不必要了。

## 1.8 Using the EurekaClient ##
一旦你的app注解了`@EnableDiscoveryClient`(或`@EnableEurekaClient`)，就可以用它来从Eureka Server中发现服务实例。
一种方式是使用原生的`com.netflix.discovery.EurekaClient`(对照Spring Cloud的`DiscoveryClient`)。
```java
    @Autowired
    private EurekaClient discoveryClient;
    
    public String serviceUrl() {
    InstanceInfo instance = discoveryClient.getNextServerFromEureka("STORES", false);
    return instance.getHomePageUrl();
    }
```
> 不要在`@PostConstruct`方法或者`@Scheduled`方法(或者任何 `ApplicationContext`还未开始的地方)中使用`EurekaClient`。
> `EurekaClient`在`SmartLifecycle`(设置`phase=0`)中初始化，因此确定它可用的最早时机是另一个更高phase值的`SmartLifecycle`中。

### 1.8.1 EurekaClient without Jersey ###

一般 EurekaClient使用Jersey进行HTTP通讯。如果不需要Jersey的依赖性, 可以从依赖性中排除。 
Spring Cloud能够自动配置依赖Spring RestTemplate的传送客户端（transport client）。
```xml
    <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-eureka</artifactId>
    <exclusions>
    <exclusion>
    <groupId>com.sun.jersey</groupId>
    <artifactId>jersey-client</artifactId>
    </exclusion>
    <exclusion>
    <groupId>com.sun.jersey</groupId>
    <artifactId>jersey-core</artifactId>
    </exclusion>
    <exclusion>
    <groupId>com.sun.jersey.contribs</groupId>
    <artifactId>jersey-apache-client4</artifactId>
    </exclusion>
    </exclusions>
    </dependency>
```
## 1.9 Alternatives to the native Netflix EurekaClient ##
使用原生Netflix的`EurekaClient`不是必须的，但是在某种程度上，通过封装类使用会更方便。
Spring Cloud支持 [Feign](https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.4.4.RELEASE/multi/multi_spring-cloud-feign.html)
(REST客户端构造器)或使用逻辑Eureka服务定位器(VIPs)的Spring [RestTemplate](https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.4.4.RELEASE/multi/multi_spring-cloud-ribbon.html)来代替物理的URLs。
使用一系列固定的物理服务器来配置Ribbon，可以通过简单地设置`<client>.ribbon.listOfServers`为逗号间隔的物理地址列表(或主机名称), 
该地址中`<client>`是客户端的ID。

也可以使用非Netflix特性的`org.springframework.cloud.client.discovery.DiscoveryClient`，同样提供了发现客户端的简答API, 例.
```java
    @Autowired
    private DiscoveryClient discoveryClient;
    
    public String serviceUrl() {
        List<ServiceInstance> list = discoveryClient.getInstances("STORES");
        if (list != null && list.size() > 0 ) {
            return list.get(0).getUri();
        }
        return null;
    }
```
## 1.10 Why is it so Slow to Register a Service? ##
注册成为一个Eureka实例同时需要向注册表(客户端配置的`serviceUrl`)发起周期性的心跳，默认周期为30秒。
只有实例、服务器和客户端在各自的本地缓存中具有相同的元数据 (这个过程需要花费3次心跳的时间)，服务才会被客户端发现。
也可以通过`eureka.instance.leaseRenewalIntervalInSeconds`改变周期，这样就可以加速客户端连接其他services的过程。
生产中保持缺省值会更好，因为有一些服务内部会执行一些计算，这会消耗租约续期的周期。

## 1.11 Zones ##

如果你把Eureka客户端部署到不同的区域，你可能更希望客户端租赁相同区域的服务，之后再尝试其他区域的服务。要实现这样的场景，就需要正确地配置Eureka客户端。  
首先，需要确保把Eureka服务器部署到每一个zone，并且互为对等点（peers）。 
查看[zones and regions](https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.4.4.RELEASE/multi/multi_spring-cloud-eureka-server.html#spring-cloud-eureka-server-zones-and-regions)这一章获取更详细的信息.

接下来需要通知Eureka你的服务在哪个区域。可以使用`metadataMap`属性来实现。
例如，如果`service 1`被配置到`zone 1 `和`zone 2`你需要在`service 1`里按照如下所示来设置Eureka属性。  
**区域1的服务**
```properties
    eureka.instance.metadataMap.zone = zone1
    eureka.client.preferSameZoneEureka = true
```
**区域2的服务**
```properties
    eureka.instance.metadataMap.zone = zone2
    eureka.client.preferSameZoneEureka = true
```
